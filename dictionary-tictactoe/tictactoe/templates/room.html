{% load static %}
<!DOCTYPE html>
<html>

<head>
    <meta charset="utf-8" />
    <title>Tictactoe Room</title>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/css/bootstrap.min.css" rel="stylesheet"
        integrity="sha384-1BmE4kWBq78iYhFldvKuhfTAU6auU8tT94WrHftjDbrCEXSU1oBoqyl2QvZ6jIW3" crossorigin="anonymous">

    <link rel="stylesheet" href="{% static 'css/styles.css' %}">
</head>

<body>
    <div class="container">
        <div class="row">
            <div class="col d-flex justify-content-center text-center">
                <table id="dictionary-table"></table>
            </div>
        </div>
        <div class="row">
            <div class="col d-flex justify-content-center text-center">
                <table id="palette-table">
                    <caption style="caption-side:top">Your Palette</caption>
                </table>
            </div>
            <div class="col d-flex justify-content-center text-center">
                <table id="opponent-palette-table">
                    <caption style="caption-side:top">Opponent Palette</caption>
                </table>
            </div>
        </div>
        <div class="row">
            <div class="col">
                <h3>Selected Letter: </h3>
                <h3 id="selectedLetter"></h3>
            </div>
        </div>
    </div>

    <script src={% static 'js/util.js' %}></script>
    
    <script>
        class Player{
            constructor(roomSocket, name) {
                this.roomSocket = roomSocket
                this.name = name
                this.opponents = []
            }
            
            set palette(palette) {
                this._palette = palette
                this.syncPaletteData("palette-table", this._palette)
            }

            set letter(letter) {
                if (this._palette.includes(letter)){
                    this._selectedLetter = letter
                    this.updateSelectedLetterHtml()
                }
            }

            sendLetter(x, y) {                
                this.roomSocket.send(JSON.stringify({ "type": 100, "x": x, "y": y, "letter" : this._selectedLetter}))
            }

            stealPalette() {                
                this.roomSocket.send(JSON.stringify({ "type": 2, "player" : this.opponents[0]}))
            }
            
            updateSelectedLetterHtml() {
                document.querySelector("#selectedLetter").innerHTML = this._selectedLetter
            }            

            syncPaletteData() {
                let row_by_colums_palette_tds = listToMatrix(document.querySelectorAll(`#palette-table * > td`), 5)
                let palette = listToMatrix(this._palette, 5)
                let i, j;
                for (i = 0; i < row_by_colums_palette_tds.length; i++) {
                    for (j = 0; j < row_by_colums_palette_tds[i].length; j++) {
                        row_by_colums_palette_tds[i][j].innerHTML = palette[i][j]
                        addSelectLetterEmitter(this, row_by_colums_palette_tds[i][j], row_by_colums_palette_tds[i][j].innerHTML)
                    }
                }
            }
        }

        createTable("dictionary-table", 10,10)
        createTable("palette-table", 2, 5)
        createTable("opponent-palette-table", 2, 5)


        var tds = document.querySelectorAll("#dictionary-table * > td")
        var row_by_column_tds = listToMatrix(tds, 10)

        function syncOpponentPaletteData(palette) {
            let row_by_colums_palette_tds = listToMatrix(document.querySelectorAll(`#opponent-palette-table * > td`), 5)
            let _palette = listToMatrix(palette, 5)
            let i, j;
            for (i = 0; i < row_by_colums_palette_tds.length; i++) {
                for (j = 0; j < row_by_colums_palette_tds[i].length; j++) {
                    row_by_colums_palette_tds[i][j].innerHTML = _palette[i][j]
                }
            }
        }
        
        function syncGameData(game_data) {
            var i, j;
            for (i = 0; i < row_by_column_tds.length; i++) {
                for (j = 0; j < row_by_column_tds[i].length; j++) {
                    row_by_column_tds[i][j].innerHTML = game_data[i][j]
                }
            }
        }
        
        function addEmitters(player, td, x, y) {
            td.onclick = () => player.sendLetter(x,y)
        }
        
        function addSelectLetterEmitter(player, td, letter) {
            td.onclick = () => player.letter = letter
        }
        
        var wsStart = window.location.protocol == 'https:' ? 'wss://' : 'ws://'
        
        const roomSocket = new WebSocket(
            wsStart
            + window.location.host
            + '/ws/room/{{room_name}}/'
            );
            
        var player = new Player(roomSocket, "");

        roomSocket.onmessage = (e) => {
            var data = JSON.parse(e.data)
            console.log(data)
            // TODO
            // Add stealing mechanic to the frontends

            if (data["type"] == 0) {
                player.name = data["message"]["player"]
                player.palette = data["message"]["palette"]
                
                for (var x = 0; x < row_by_column_tds.length; x++) {
                    for (var y = 0; y < row_by_column_tds[x].length; y++) {
                        addEmitters(player, row_by_column_tds[x][y], x, y)
                    }
                }
            }

            else if (data["type"] == 1) {
                disconnected_player_name = data["message"]
                let index = player.opponents.indexOf(disconnected_player_name)
                if (index !== -1) {
                    player.opponents.splice(index, 1);
                }
            }

            else if (data["type"] == 20 ) {
                // sync the initial game
                game_data = data["message"]["game_state"]
                syncGameData(game_data)
                // set the opponent
                players = data["message"]["players"]
                players.forEach(
                    (e)=>{
                        if(e["name"] !== player.name) {
                            player.opponents.push(e["name"])
                            // TODO, fix this for more than 2 players 
                            syncOpponentPaletteData(e["palette"])
                        }
                    }
                )
            }
            
            else if (data["type"] == 100) {
                game_data = data["message"]["game_state"]
                syncGameData(game_data)
            }

            else if (data["type"] == 30) {
                if (data["message"]["winner"] == player.name) {
                    alert("You won the game!\nRefresh the page to start a new game.")
                } else{
                    alert("You lost the game.\nRefresh the page to start a new game.")
                }
            }

            else if (data["type"] == 200) {
                // find the player inside the data
                players = data["message"]
                players.forEach(
                    (e) => {
                        // TODO, fix this for more than 2 players 
                        if(e["name"] === player.name){
                            // set the player palette
                            player.palette = e["palette"]
                        }
                        else {
                            // if the name of the player isn't equal to e["name"]
                            // it means it is the opponent, so set opponent palette
                            syncOpponentPaletteData(e["palette"])
                        }
                    }
                )
            }
        };
        roomSocket.onclose = (e) => { console.log(e) };
    </script>
</body>

</html>